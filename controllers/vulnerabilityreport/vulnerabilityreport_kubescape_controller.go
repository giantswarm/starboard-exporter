/*
	Copyright 2025 Giant Swarm.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

    	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

package vulnerabilityreport

import (
	"context"
	"fmt"
	"strings"

	"github.com/go-logr/logr"
	kubescape "github.com/kubescape/storage/pkg/apis/softwarecomposition/v1beta1"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	apitypes "k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/metrics"

	"github.com/giantswarm/starboard-exporter/controllers"
	"github.com/giantswarm/starboard-exporter/utils"
)

// KubescapeVulnerabilityReportReconciler reconciles Kubescape VulnerabilityManifest objects
type KubescapeVulnerabilityReportReconciler struct {
	client.Client
	Log    logr.Logger
	Scheme *runtime.Scheme

	MaxJitterPercent int
	ShardHelper      *utils.ShardHelper
	TargetLabels     []VulnerabilityLabel
}

// Reconcile is part of the main kubernetes reconciliation loop
func (r *KubescapeVulnerabilityReportReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	_ = log.FromContext(ctx)
	_ = r.Log.WithValues("kubescapevulnerabilityreport", req.NamespacedName)

	registerMetricsOnce.Do(r.registerMetrics)

	// The report has changed, meaning our metrics are out of date for this report. Clear them.
	deletedSummaries := VulnerabilitySummary.DeletePartialMatch(prometheus.Labels{"report_name": req.String()})
	deletedDetails := VulnerabilityInfo.DeletePartialMatch(prometheus.Labels{"report_name": req.String()})

	shouldOwn := r.ShardHelper.ShouldOwn(req.String())
	if shouldOwn {

		// Try to get the manifest. It might not exist anymore, in which case we don't need to do anything.
		manifest := &kubescape.VulnerabilityManifest{}
		if err := r.Get(ctx, req.NamespacedName, manifest); err != nil {
			if apierrors.IsNotFound(err) {
				// Most likely the manifest was deleted.
				return ctrl.Result{}, nil
			}

			// Error reading the object.
			r.Log.Error(err, "Unable to read manifest")
			return ctrl.Result{}, err
		}

		// Extract counts from manifest by iterating matches (do this once for both logging and metrics)
		counts := getCountPerSeverityFromManifest(manifest, r.Log)
		r.Log.Info(fmt.Sprintf("Reconciled %s || Found (C/H/M/L/N/U): %d/%d/%d/%d/%d/%d",
			req.NamespacedName,
			int(counts["CRITICAL"]),
			int(counts["HIGH"]),
			int(counts["MEDIUM"]),
			int(counts["LOW"]),
			int(counts["NEGLIGIBLE"]),
			int(counts["UNKNOWN"]),
		))

		// Publish metrics (pass pre-calculated counts to avoid iterating again)
		publishSummaryMetricsFromKubescape(manifest, counts)
		if len(r.TargetLabels) > 0 {
			publishDetailMetricsFromKubescape(manifest, r.TargetLabels)
		}

		// Add a label to this manifest so any previous owners will reconcile and drop the metric.
		if manifest.Labels == nil {
			manifest.Labels = make(map[string]string)
		}
		manifest.Labels[controllers.ShardOwnerLabel] = r.ShardHelper.PodIP
		err := r.Update(ctx, manifest, &client.UpdateOptions{})
		if err != nil {
			r.Log.Error(err, "unable to add shard owner label")
		}
	} else {
		if deletedSummaries > 0 || deletedDetails > 0 {
			r.Log.Info(fmt.Sprintf("cleared %d summary and %d detail metrics", deletedSummaries, deletedDetails))
		}
	}

	return utils.JitterRequeue(controllers.DefaultRequeueDuration, r.MaxJitterPercent, r.Log), nil
}

// getCountPerSeverityFromManifest extracts counts by iterating through manifest matches
func getCountPerSeverityFromManifest(manifest *kubescape.VulnerabilityManifest) map[string]float64 {
	counts := map[string]float64{
		"CRITICAL":   0,
		"HIGH":       0,
		"MEDIUM":     0,
		"LOW":        0,
		"NEGLIGIBLE": 0,
		"UNKNOWN":    0,
	}

	// Track unrecognized severities to log them
	unrecognizedSeverities := make(map[string]int)

	// Iterate through matches to count by severity
	for _, match := range manifest.Spec.Payload.Matches {
		originalSeverity := match.Vulnerability.Severity
		severity := strings.ToUpper(originalSeverity)
		if _, exists := counts[severity]; exists {
			counts[severity]++
		} else {
			// Unknown or unrecognized severity
			counts["UNKNOWN"]++
			unrecognizedSeverities[originalSeverity]++
		}
	}

	// Log unrecognized severities
	for severity, count := range unrecognizedSeverities {
		log.Info(fmt.Sprintf("unrecognized severity %q, marking %d vulnerabilities as Unknown", severity, count))
	}

	return counts
}

// publishSummaryMetricsFromKubescape publishes summary metrics from a VulnerabilityManifest
func publishSummaryMetricsFromKubescape(manifest *kubescape.VulnerabilityManifest, counts map[string]float64) {
	summaryValues := valuesForKubescapeManifest(manifest, LabelsForGroup(labelGroupSummary))

	// Add the severity label after the standard labels and expose each severity metric
	for severity, count := range counts {
		v := summaryValues
		v["severity"] = severity

		// Expose the metric
		VulnerabilitySummary.With(v).Set(count)
	}
}

// publishDetailMetricsFromKubescape publishes per-CVE detail metrics from a VulnerabilityManifest
func publishDetailMetricsFromKubescape(manifest *kubescape.VulnerabilityManifest, targetLabels []VulnerabilityLabel) {
	reportValues := valuesForKubescapeManifest(manifest, targetLabels)

	// Iterate through matches (individual CVEs)
	for _, match := range manifest.Spec.Payload.Matches {
		vulnValues := valuesForKubescapeVulnerability(match, targetLabels)

		// Include the report-level values
		for label, value := range reportValues {
			vulnValues[label] = value
		}

		// Use CVSS score as the metric value
		score := float64(0)
		if len(match.Vulnerability.Cvss) > 0 {
			// Use the first CVSS score (typically v3.1)
			score = match.Vulnerability.Cvss[0].Metrics.BaseScore
		}

		// Expose the metric
		VulnerabilityInfo.With(vulnValues).Set(score)
	}
}

func (r *KubescapeVulnerabilityReportReconciler) registerMetrics() {

	VulnerabilityInfo = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: metricNamespace,
			Subsystem: metricSubsystem,
			Name:      "image_vulnerability",
			Help:      "Indicates the presence of a CVE in an image.",
		},
		LabelNamesForList(r.TargetLabels),
	)

	metrics.Registry.MustRegister(VulnerabilityInfo)
}

// SetupWithManager sets up the controller with the Manager
func (r *KubescapeVulnerabilityReportReconciler) SetupWithManager(mgr ctrl.Manager) error {
	err := ctrl.NewControllerManagedBy(mgr).
		For(&kubescape.VulnerabilityManifest{}).
		Complete(r)
	if err != nil {
		return errors.Wrap(err, "failed setting up controller with controller manager")
	}
	return nil
}

// valuesForKubescapeManifest extracts report-level label values from a VulnerabilityManifest
func valuesForKubescapeManifest(manifest *kubescape.VulnerabilityManifest, labels []VulnerabilityLabel) map[string]string {
	result := map[string]string{}
	for _, label := range labels {
		if label.Scope == FieldScopeReport {
			result[label.Name] = kubescapeManifestValueFor(label.Name, manifest)
		}
	}
	return result
}

// valuesForKubescapeVulnerability extracts vulnerability-level label values from a Kubescape Match
func valuesForKubescapeVulnerability(match kubescape.Match, labels []VulnerabilityLabel) map[string]string {
	result := map[string]string{}
	for _, label := range labels {
		if label.Scope == FieldScopeVulnerability {
			result[label.Name] = kubescapeVulnValueFor(label.Name, match)
		}
	}
	return result
}

// kubescapeManifestValueFor maps field names to VulnerabilityManifest fields
func kubescapeManifestValueFor(field string, manifest *kubescape.VulnerabilityManifest) string {
	switch field {
	case "scanner":
		return "kubescape"
	case "report_name":
		return apitypes.NamespacedName{Name: manifest.Name, Namespace: manifest.Namespace}.String()
	case "image_namespace":
		return manifest.Namespace
	case "image_registry":
		if manifest.Annotations != nil {
			if imageTag, ok := manifest.Annotations["kubescape.io/image-tag"]; ok {
				return parseImageRegistry(imageTag)
			}
		}
		return ""
	case "image_repository":
		if manifest.Annotations != nil {
			if imageTag, ok := manifest.Annotations["kubescape.io/image-tag"]; ok {
				return parseImageRepository(imageTag)
			}
		}
		return ""
	case "image_tag":
		if manifest.Annotations != nil {
			if imageTag, ok := manifest.Annotations["kubescape.io/image-tag"]; ok {
				return parseImageTag(imageTag)
			}
		}
		return ""
	case "image_digest":
		if manifest.Annotations != nil {
			if imageID, ok := manifest.Annotations["kubescape.io/image-id"]; ok {
				return parseImageDigest(imageID)
			}
		}
		return ""
	default:
		return ""
	}
}

// parseImageRegistry extracts the registry from a full image reference
// Example: "kubescape.io/image-tag: docker.io/library/nginx:1.19.0" -> "docker.io"
func parseImageRegistry(imageRef string) string {
	// Find the first slash
	slashIdx := strings.Index(imageRef, "/")
	if slashIdx == -1 {
		// No slash means no registry specified
		// Default to docker.io
		return "docker.io"
	}

	imageRegistry := imageRef[:slashIdx]

	// Check if the first part is actually a registry
	// The first portion is only a registry if it contains ".", ":", or "localhost"
	if strings.Contains(imageRegistry, ".") || strings.Contains(imageRegistry, ":") || imageRegistry == "localhost" {
		return imageRegistry
	}

	return imageRegistry
}

// parseImageRepository extracts the repository from a full image reference
// Example: "kubescape.io/image-tag: docker.io/library/nginx:1.19.0" -> "library/nginx"
func parseImageRepository(imageRef string) string {

	refWithoutTagDigest := imageRef

	// Remove digest if present (everything after @)
	if atIdx := strings.Index(refWithoutTagDigest, "@"); atIdx != -1 {
		refWithoutTagDigest = refWithoutTagDigest[:atIdx]
	}

	// Remove tag if present (everything after last :)
	if colonIdx := strings.LastIndex(refWithoutTagDigest, ":"); colonIdx != -1 {
		// Check if this colon is part of a port number in the registry
		slashAfterColon := strings.Index(refWithoutTagDigest[colonIdx:], "/")
		if slashAfterColon == -1 {
			// No slash after colon, so it's a tag
			refWithoutTagDigest = refWithoutTagDigest[:colonIdx]
		}
	}

	// Find the first slash (separates registry from repository)
	// The first portion is only a registry if it contains ".", ":", or "localhost"
	slashIdx := strings.Index(refWithoutTagDigest, "/")
	if slashIdx == -1 {
		// No slash means no registry specified (e.g., "nginx")
		// Assume it's a Docker Hub library image
		return "library/" + refWithoutTagDigest
	}

	registry := refWithoutTagDigest[:slashIdx]
	repository := refWithoutTagDigest[slashIdx+1:]

	// Check if the first part is actually a registry
	if strings.Contains(registry, ".") || strings.Contains(registry, ":") || registry == "localhost" {
		// It's a registry, return the repository part
		return repository
	}

	// Otherwise, the first part is a Docker Hub user/org, not a registry
	// Return the whole thing (user/image)
	return refWithoutTagDigest
}

// parseImageTag extracts the tag from a full image reference
// Example: "kubescape.io/image-tag: docker.io/library/nginx:1.19.0" -> "1.19.0"
func parseImageTag(imageRef string) string {
	// Remove digest if present (everything after @)
	if atIdx := strings.Index(imageRef, "@"); atIdx != -1 {
		imageRef = imageRef[:atIdx]
	}

	// Find the last colon (separates repository from tag)
	colonIdx := strings.LastIndex(imageRef, ":")
	if colonIdx == -1 {
		// No tag specified
		return ""
	}

	imageTag := imageRef[colonIdx+1:]

	return imageTag
}

// parseImageDigest extracts the digest from a full image reference
// Example: "docker.io/library/nginx@sha256:21f32f6c..." -> "sha256:21f32f6c..."
// Example: "nginx:latest" -> "" (no digest)
func parseImageDigest(imageRef string) string {
	// Find the @ symbol
	atIdx := strings.Index(imageRef, "@")
	if atIdx == -1 {
		// No digest specified
		return ""
	}

	return imageRef[atIdx+1:]
}

// kubescapeVulnValueFor maps field names to Kubescape Match vulnerability fields
func kubescapeVulnValueFor(field string, match kubescape.Match) string {
	switch field {
	case "vulnerability_id":
		return match.Vulnerability.ID
	case "vulnerable_resource_name":
		return match.Artifact.Name
	case "installed_resource_version":
		return match.Artifact.Version
	case "fixed_resource_version":
		if len(match.Vulnerability.Fix.Versions) > 0 {
			return match.Vulnerability.Fix.Versions[0]
		}
		return ""
	case "vulnerability_title":
		if match.Vulnerability.Description != "" {
			return match.Vulnerability.Description
		}
		return match.Vulnerability.ID
	case "vulnerability_link":
		if len(match.Vulnerability.URLs) > 0 {
			return match.Vulnerability.URLs[0]
		}
		return ""
	case "severity":
		// Match Trivy by using uppercase
		return strings.ToUpper(match.Vulnerability.Severity)
	default:
		return ""
	}
}

// RequeueKubescapeReportsForPod requeues all Kubescape vulnerability manifests owned by this pod
func RequeueKubescapeReportsForPod(c client.Client, log logr.Logger, podIP string) {
	manifestList := &kubescape.VulnerabilityManifestList{}
	opts := []client.ListOption{
		client.MatchingLabels{controllers.ShardOwnerLabel: podIP},
	}

	// Get the list of manifests with our label
	err := c.List(context.Background(), manifestList, opts...)
	if err != nil {
		log.Error(err, "unable to fetch kubescape vulnerabilitymanifests")
		return
	}

	for _, r := range manifestList.Items {
		// Retrieve the individual manifest
		manifest := &kubescape.VulnerabilityManifest{}
		err := c.Get(context.Background(), client.ObjectKey{Name: r.Name, Namespace: r.Namespace}, manifest)
		if err != nil {
			log.Error(err, "unable to fetch kubescape vulnerabilitymanifest")
			continue
		}

		// Clear the shard-owner label if it still has our label
		if manifest.Labels != nil && manifest.Labels[controllers.ShardOwnerLabel] == podIP {
			manifest.Labels[controllers.ShardOwnerLabel] = ""
			err = c.Update(context.Background(), manifest, &client.UpdateOptions{})
			if err != nil {
				log.Error(err, fmt.Sprintf("unable to remove %s label from kubescape manifest", controllers.ShardOwnerLabel))
			}
		}
	}
}
