/*
	Copyright 2025 Giant Swarm.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

    	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

package vulnerabilityreport

import (
	"context"
	"fmt"
	"strings"

	"github.com/containers/image/v5/docker/reference"
	"github.com/go-logr/logr"
	kubescape "github.com/kubescape/storage/pkg/apis/softwarecomposition/v1beta1"
	"github.com/pkg/errors"
	"github.com/prometheus/client_golang/prometheus"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/runtime"
	apitypes "k8s.io/apimachinery/pkg/types"
	ctrl "sigs.k8s.io/controller-runtime"
	"sigs.k8s.io/controller-runtime/pkg/client"

	"sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/metrics"

	"github.com/giantswarm/starboard-exporter/controllers"
	"github.com/giantswarm/starboard-exporter/utils"
)

const (
	// Annotation key for the image name, including tag, in Kubescape VulnerabilityManifests
	kubescapeImageTagAnnotation = "kubescape.io/image-tag"
	// Annotation key for the image ID (digest) in Kubescape VulnerabilityManifests
	kubescapeImageIDAnnotation = "kubescape.io/image-id"
	// Preferred CVSS version
	preferredCvssVersion = "3.1"
)

// KubescapeVulnerabilityManifestReconciler reconciles Kubescape VulnerabilityManifest objects
type KubescapeVulnerabilityManifestReconciler struct {
	client.Client
	Log    logr.Logger
	Scheme *runtime.Scheme

	MaxJitterPercent int
	ShardHelper      *utils.ShardHelper
	TargetLabels     []VulnerabilityLabel
}

func (r *KubescapeVulnerabilityManifestReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {
	_ = log.FromContext(ctx)
	_ = r.Log.WithValues("kubescapevulnerabilityreport", req.NamespacedName)

	registerMetricsOnce.Do(r.registerMetrics)

	// The manifest has changed, meaning our metrics are out of date for this report. Clear them.
	deletedSummaries := VulnerabilitySummary.DeletePartialMatch(prometheus.Labels{"report_name": req.String()})
	deletedDetails := VulnerabilityInfo.DeletePartialMatch(prometheus.Labels{"report_name": req.String()})

	shouldOwn := r.ShardHelper.ShouldOwn(req.String())
	if shouldOwn {

		// Try to get the manifest. It might not exist anymore, in which case we don't need to do anything.
		manifest := &kubescape.VulnerabilityManifest{}
		if err := r.Get(ctx, req.NamespacedName, manifest); err != nil {
			if apierrors.IsNotFound(err) {
				// Most likely the manifest was deleted.
				return ctrl.Result{}, nil
			}

			// Error reading the object.
			r.Log.Error(err, "Unable to read manifest")
			return ctrl.Result{}, err
		}

		// Count the number of vulnerabilities for each severity from the manifest
		counts := getCountPerSeverityFromManifest(manifest, r.Log)
		r.Log.Info(fmt.Sprintf("Reconciled %s || Found (C/H/M/L/N/U): %d/%d/%d/%d/%d/%d",
			req.NamespacedName,
			int(counts["CRITICAL"]),
			int(counts["HIGH"]),
			int(counts["MEDIUM"]),
			int(counts["LOW"]),
			int(counts["NEGLIGIBLE"]),
			int(counts["UNKNOWN"]),
		))

		// Publish metrics
		publishSummaryMetricsFromKubescape(manifest, counts)
		if len(r.TargetLabels) > 0 {
			publishDetailMetricsFromKubescape(manifest, r.TargetLabels)
		}

		// Add a label to this manifest so any previous owners will reconcile and drop the metric.
		if manifest.Labels == nil {
			manifest.Labels = make(map[string]string)
		}
		manifest.Labels[controllers.ShardOwnerLabel] = r.ShardHelper.PodIP
		err := r.Update(ctx, manifest, &client.UpdateOptions{})
		if err != nil {
			r.Log.Error(err, "unable to add shard owner label")
		}
	} else {
		if deletedSummaries > 0 || deletedDetails > 0 {
			r.Log.Info(fmt.Sprintf("cleared %d summary and %d detail metrics", deletedSummaries, deletedDetails))
		}
	}

	return utils.JitterRequeue(controllers.DefaultRequeueDuration, r.MaxJitterPercent, r.Log), nil
}

func getCountPerSeverityFromManifest(manifest *kubescape.VulnerabilityManifest, log logr.Logger) map[string]float64 {
	counts := map[string]float64{
		"CRITICAL":   0,
		"HIGH":       0,
		"MEDIUM":     0,
		"LOW":        0,
		"NEGLIGIBLE": 0,
		"UNKNOWN":    0,
	}

	// Track unrecognized severities to log them
	unrecognizedSeverities := make(map[string]int)

	// Iterate through matches to count by severity
	for _, match := range manifest.Spec.Payload.Matches {
		originalSeverity := match.Vulnerability.Severity
		severity := strings.ToUpper(originalSeverity)
		if _, exists := counts[severity]; exists {
			counts[severity]++
		} else {
			// Unknown or unrecognized severity
			counts["UNKNOWN"]++
			unrecognizedSeverities[originalSeverity]++
		}
	}

	// Log unrecognized severities
	for severity, count := range unrecognizedSeverities {
		log.Info(fmt.Sprintf("unrecognized severity %q, marking %d vulnerabilities as Unknown", severity, count))
	}

	return counts
}

func publishSummaryMetricsFromKubescape(manifest *kubescape.VulnerabilityManifest, counts map[string]float64) {
	summaryValues := valuesForKubescapeManifest(manifest, LabelsForGroup(labelGroupSummary))

	// Add the severity label after the standard labels and expose each severity metric
	for severity, count := range counts {
		v := summaryValues
		v["severity"] = severity

		// Expose the metric
		VulnerabilitySummary.With(v).Set(count)
	}
}

func publishDetailMetricsFromKubescape(manifest *kubescape.VulnerabilityManifest, targetLabels []VulnerabilityLabel) {
	manifestValues := valuesForKubescapeManifest(manifest, targetLabels)

	// Iterate through matches (individual CVEs)
	for _, match := range manifest.Spec.Payload.Matches {
		vulnValues := valuesForKubescapeVulnerability(match, targetLabels)

		// Include the manifest-level values
		for label, value := range manifestValues {
			vulnValues[label] = value
		}

		// Use CVSS score as the metric value
		// Prefer CVSS 3.1 if available, otherwise use highest version
		score := float64(0)
		highestVersion := ""
		for _, cvss := range match.Vulnerability.Cvss {
			if cvss.Version == preferredCvssVersion {
				score = cvss.Metrics.BaseScore
				break
			}
			if cvss.Version > highestVersion {
				highestVersion = cvss.Version
				score = cvss.Metrics.BaseScore
			}
		}

		// Expose the metric
		VulnerabilityInfo.With(vulnValues).Set(score)
	}
}

func (r *KubescapeVulnerabilityManifestReconciler) registerMetrics() {

	VulnerabilityInfo = prometheus.NewGaugeVec(
		prometheus.GaugeOpts{
			Namespace: metricNamespace,
			Subsystem: metricSubsystem,
			Name:      "image_vulnerability",
			Help:      "Indicates the presence of a CVE in an image.",
		},
		LabelNamesForList(r.TargetLabels),
	)

	metrics.Registry.MustRegister(VulnerabilityInfo)
}

// SetupWithManager sets up the controller with the Manager
func (r *KubescapeVulnerabilityManifestReconciler) SetupWithManager(mgr ctrl.Manager) error {
	err := ctrl.NewControllerManagedBy(mgr).
		For(&kubescape.VulnerabilityManifest{}).
		Complete(r)
	if err != nil {
		return errors.Wrap(err, "failed setting up controller with controller manager")
	}
	return nil
}

func valuesForKubescapeManifest(manifest *kubescape.VulnerabilityManifest, labels []VulnerabilityLabel) map[string]string {
	result := map[string]string{}

	// parse image tag reference only when first needed, then reuse
	var parsedImageRef reference.Named
	parseImageRef := func() reference.Named {
		if parsedImageRef == nil && manifest.Annotations != nil {
			if imageTag, ok := manifest.Annotations[kubescapeImageTagAnnotation]; ok {
				if ref, err := reference.ParseNormalizedNamed(imageTag); err == nil {
					parsedImageRef = ref
				}
			}
		}
		return parsedImageRef
	}

	for _, label := range labels {
		if label.Scope == FieldScopeReport {
			result[label.Name] = kubescapeManifestValueFor(label.Name, manifest, parseImageRef)
		}
	}
	return result
}

func valuesForKubescapeVulnerability(match kubescape.Match, labels []VulnerabilityLabel) map[string]string {
	result := map[string]string{}
	for _, label := range labels {
		if label.Scope == FieldScopeVulnerability {
			result[label.Name] = kubescapeVulnValueFor(label.Name, match)
		}
	}
	return result
}

func kubescapeManifestValueFor(field string, manifest *kubescape.VulnerabilityManifest, getParsedImageRef func() reference.Named) string {
	switch field {
	case "scanner":
		return "kubescape"
	case "report_name":
		return apitypes.NamespacedName{Name: manifest.Name, Namespace: manifest.Namespace}.String()
	case "image_namespace":
		return manifest.Namespace
	case "image_registry":
		if ref := getParsedImageRef(); ref != nil {
			return reference.Domain(ref)
		}
		return ""
	case "image_repository":
		if ref := getParsedImageRef(); ref != nil {
			return reference.Path(ref)
		}
		return ""
	case "image_tag":
		if ref := getParsedImageRef(); ref != nil {
			if tagged, ok := ref.(reference.Tagged); ok {
				return tagged.Tag()
			}
		}
		return ""
	case "image_digest":
		if manifest.Annotations != nil {
			if imageID, ok := manifest.Annotations[kubescapeImageIDAnnotation]; ok {
				if ref, err := reference.ParseAnyReference(imageID); err == nil {
					if digested, ok := ref.(reference.Digested); ok {
						return digested.Digest().String()
					}
				}
			}
		}
		return ""
	default:
		return ""
	}
}

func kubescapeVulnValueFor(field string, match kubescape.Match) string {
	switch field {
	case "vulnerability_id":
		return match.Vulnerability.ID
	case "vulnerable_resource_name":
		return match.Artifact.Name
	case "installed_resource_version":
		return match.Artifact.Version
	case "fixed_resource_version":
		if len(match.Vulnerability.Fix.Versions) > 0 {
			return match.Vulnerability.Fix.Versions[0]
		}
		return ""
	case "vulnerability_title":
		if match.Vulnerability.Description != "" {
			return match.Vulnerability.Description
		}
		return match.Vulnerability.ID
	case "vulnerability_link":
		if len(match.Vulnerability.URLs) > 0 {
			return match.Vulnerability.URLs[0]
		}
		return ""
	case "severity":
		// Match Trivy by using uppercase
		return strings.ToUpper(match.Vulnerability.Severity)
	default:
		return ""
	}
}

func RequeueKubescapeManifestsForPod(c client.Client, log logr.Logger, podIP string) {
	manifestList := &kubescape.VulnerabilityManifestList{}
	opts := []client.ListOption{
		client.MatchingLabels{controllers.ShardOwnerLabel: podIP},
	}

	// Get the list of manifests with our label
	err := c.List(context.Background(), manifestList, opts...)
	if err != nil {
		log.Error(err, "unable to fetch kubescape vulnerabilitymanifests")
		return
	}

	for _, r := range manifestList.Items {
		// Retrieve the individual manifest
		manifest := &kubescape.VulnerabilityManifest{}
		err := c.Get(context.Background(), client.ObjectKey{Name: r.Name, Namespace: r.Namespace}, manifest)
		if err != nil {
			log.Error(err, "unable to fetch kubescape vulnerabilitymanifest")
			continue
		}

		// Clear the shard-owner label if it still has our label
		if manifest.Labels != nil && manifest.Labels[controllers.ShardOwnerLabel] == podIP {
			manifest.Labels[controllers.ShardOwnerLabel] = ""
			err = c.Update(context.Background(), manifest, &client.UpdateOptions{})
			if err != nil {
				log.Error(err, fmt.Sprintf("unable to remove %s label from kubescape manifest", controllers.ShardOwnerLabel))
			}
		}
	}
}
