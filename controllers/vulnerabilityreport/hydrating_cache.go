/*
	Copyright 2025 Giant Swarm.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

    	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

package vulnerabilityreport

import (
	"context"
	"sync"

	kubescape "github.com/kubescape/storage/pkg/apis/softwarecomposition/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/cache"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type manifestEntry struct {
	resourceVersion string
	manifest        *kubescape.VulnerabilityManifest
}

// HydratingCache wraps a standard controller-runtime cache to provide "read-through"
// hydration for Kubescape VulnerabilityManifest objects which are missing report
// data when listed.
type HydratingCache struct {
	cache.Cache
	apiReader   client.Reader
	detailStore sync.Map // map[string]manifestEntry
}

func NewHydratingCache(baseCache cache.Cache, apiReader client.Reader) *HydratingCache {
	return &HydratingCache{
		Cache:     baseCache,
		apiReader: apiReader,
	}
}

// Get satisfies the client.Reader interface. It first attempts to retrieve the object
// from the underlying cache. If the object is a Kubescape VulnerabilityManifest and
// is missing report data, it will attempt to hydrate it from the API server.
func (h *HydratingCache) Get(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) error {
	// First, try to get from the base cache
	err := h.Cache.Get(ctx, key, obj, opts...)
	if err != nil {
		return err
	}

	// Check if this is a Kubescape VulnerabilityManifest
	manifest, ok := obj.(*kubescape.VulnerabilityManifest)
	if !ok {
		return nil
	}

	// If the manifest has report data, we're good
	if len(manifest.Spec.Payload.Matches) > 0 {
		return nil
	}

	// Check the detail store to see if we already hydrated this version
	entryKey := key.String()
	if val, ok := h.detailStore.Load(entryKey); ok {
		e := val.(manifestEntry)
		if e.resourceVersion == manifest.ResourceVersion {
			// Found a hydrated version for the same ResourceVersion, populate our object
			e.manifest.DeepCopyInto(manifest)
			return nil
		}
	}

	// Not in store or stale version, hydrate from API
	hydrated := &kubescape.VulnerabilityManifest{}
	if err := h.apiReader.Get(ctx, key, hydrated, opts...); err != nil {
		return err
	}

	// Store it for next time
	h.detailStore.Store(entryKey, manifestEntry{
		resourceVersion: hydrated.ResourceVersion,
		manifest:        hydrated.DeepCopy(),
	})

	// Copy data to the output object
	hydrated.DeepCopyInto(manifest)

	return nil
}

