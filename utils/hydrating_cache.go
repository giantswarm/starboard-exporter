/*
	Copyright 2025 Giant Swarm.

	Licensed under the Apache License, Version 2.0 (the "License");
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

    	http://www.apache.org/licenses/LICENSE-2.0

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	See the License for the specific language governing permissions and
	limitations under the License.
*/

package utils

import (
	"context"
	"reflect"
	"sync"

	"sigs.k8s.io/controller-runtime/pkg/cache"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type CacheEntry struct {
	ResourceVersion string
	Object          client.Object
}

// DetailStore defines the interface for storing hydrated objects.
type DetailStore interface {
	Store(key string, entry CacheEntry)
	Load(key string) (CacheEntry, bool)
}

// SyncMapDetailStore is a thread-safe implementation of DetailStore using sync.Map.
type SyncMapDetailStore struct {
	data sync.Map
}

func (s *SyncMapDetailStore) Store(key string, entry CacheEntry) {
	s.data.Store(key, entry)
}

func (s *SyncMapDetailStore) Load(key string) (CacheEntry, bool) {
	val, ok := s.data.Load(key)
	if !ok {
		return CacheEntry{}, false
	}
	return val.(CacheEntry), true
}

// HydratingCache wraps a standard controller-runtime cache to provide "read-through"
// hydration for objects that may be missing data when retrieved from the cache.
type HydratingCache struct {
	cache.Cache
	apiReader      client.Reader
	needsHydration func(client.Object) bool
	detailStore    DetailStore
}

// NewHydratingCache creates a new HydratingCache.
// needsHydration is a function that returns true if the object retrieved from the cache
// is missing data and needs to be hydrated from the API server.
// If detailStore is nil, a default SyncMapDetailStore is used.
func NewHydratingCache(baseCache cache.Cache, apiReader client.Reader, needsHydration func(client.Object) bool, detailStore DetailStore) *HydratingCache {
	if detailStore == nil {
		detailStore = &SyncMapDetailStore{}
	}
	return &HydratingCache{
		Cache:          baseCache,
		apiReader:      apiReader,
		needsHydration: needsHydration,
		detailStore:    detailStore,
	}
}

// Get satisfies the client.Reader interface. It first attempts to retrieve the object
// from the underlying cache. If the object matches the needsHydration criteria,
// it will attempt to hydrate it from the API server or a local detail store.
func (h *HydratingCache) Get(ctx context.Context, key client.ObjectKey, obj client.Object, opts ...client.GetOption) error {
	// First, try to get from the base cache
	err := h.Cache.Get(ctx, key, obj, opts...)
	if err != nil {
		return err
	}

	// If no hydration logic provided or hydration not needed, return
	if h.needsHydration == nil || !h.needsHydration(obj) {
		return nil
	}

	entryKey := key.String()
	if val, ok := h.detailStore.Load(entryKey); ok {
		if val.ResourceVersion == obj.GetResourceVersion() {
			// Found a hydrated version for the same ResourceVersion, populate our object
			h.deepCopyInto(val.Object, obj)
			return nil
		}
	}

	// Not in store or stale version, hydrate from API.
	// We use the object passed in so it gets populated with the full data.
	if err := h.apiReader.Get(ctx, key, obj, opts...); err != nil {
		return err
	}

	// Store a deep copy for next time
	h.detailStore.Store(entryKey, CacheEntry{
		ResourceVersion: obj.GetResourceVersion(),
		Object:          obj.DeepCopyObject().(client.Object),
	})

	return nil
}

// deepCopyInto uses reflection to call the DeepCopyInto method on the source object,
// which is a standard method for Kubernetes objects generated by controller-gen.
func (h *HydratingCache) deepCopyInto(src, dst client.Object) {
	method := reflect.ValueOf(src).MethodByName("DeepCopyInto")
	if method.IsValid() {
		method.Call([]reflect.Value{reflect.ValueOf(dst)})
	}
}
